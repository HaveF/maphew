&severity &error &routine bail
/* if there are commandline arguments, make them the TODO list
&args quad tile:REST
&ty --------------------------------------------------------------------------
&ty   * [upcase %aml$file%] * Project: Updated LIMS 50k DEM * mhw * 10-Oct-2k
&ty     ::Step 8::  (see scripts\__ReadMe.aml)
&ty
&ty     - create drainage enforced 30m dem for 50k tiles
&ty
&ty     Autorun: &r %aml$file% {quad} {tile(s)}
&ty --------------------------------------------------------------------------
&if [null %quad%] &then &do
    &s pause [response '<Enter> to continue, something else to abort']
    &if not [null %pause%] &then &return %aml$file% exited by user request.
    &end

&if not [variable .library] &then &return &error Project Environment is not setup. Look for ./scripts/setenv.aml
&workspace %.home%

/* put header variables and other semi-global code here
   &set dem = dem
   &set cellsize = 30
   &set boundary = buf_1k
   &set creek = fwtc
   &set lake_ctr = lake_ctr
   &set cont_cov = fctr

/* follow ...\<quad>\<tile>\  (...\115h\115h12\)  pattern
/* check for quad placeholder (allows "&r aml_prog . 105d11 105d12 105d13")
&if %quad% = . &then &set quad = [listfile * -directory]
/* check for quad commandline args
&if [null %quad%] &then &set quad = [listfile * -directory]
/* check for tile argument
&if not [null %tile%] &then &set tile_arg = yes

&do quad &list [unquote %quad%]
  &workspace %quad%; &type ...entering %quad%
    /* check for TODO list on the command line, else TODO = existing workspaces
    &if [null %tile%] &then &set tile = [listfile * -workspace]

        &do tile &list [unquote %tile%]
            &call main
        &end

    /* if tile arg is autogenerated, null out else it won't be generated anew for next loop
    &if not [variable tile_arg] &then &set tile =

  &workspace  ..
&end

&RETURN ...[upcase %aml$fullfile%] finished normally.

/* ============================================================================
&ROUTINE MAIN
&workspace %.home%\%quad% /* in case last loop returned early, not exiting tile dir
    &if not [exists %tile% -workspace] &then &return
    /* ------------------------------------------------
    &if [exists %tile%\lock -file] &then &return
    &set lockfile = [OPEN %tile%\lock openstat -write]
    &if  %openstat% = 0 &then &type ...workspace %tile% locked
        &else &return Error %openstat% opening lockfile
    /* ------------------------------------------------
    &workspace %tile%
      /*&call kill_prev /* enable this if this is the second time around and previous grids need to be erased
    &if [exists %dem% -grid] &then &goto Fini
    &if not [exists %creek%_f -cover] &then &do
                   &type    STREAM %creek%_f does not exist!
                   &goto Fini
                   &end

    &if [exists 'segment violation.err' -file] &then &do
      &type ...this tile Segfaults, no point in trying...
      &goto Fini
      &end

      &type ...                    [date -vfull] * Minutes since last: [calc [extract 2 [show &pt all]] / 60]

       &type ...generating %cellsize%m DEM
       &call kill_diags
      /* find out what tolerances to use for this tile
      /* see TOPOGRID ERRORS text file for why here
       &call tolerances

       /* topogrid changes &format to 7, which causes any function involved with writing a projection file to screw up
       &set save_format = [show &format]

         &severity &error &ignore
          TOPOGRID %dem% %cellsize%
          BOUNDARY %boundary%
          ENFORCE ON
          DATATYPE CONTOUR
          MARGIN 0.0
          ITERATIONS 30
          TOLERANCES %Tol_1% %Tol_2% 0.0
          &if [exists %creek%_f -cover] &then STREAM %creek%_f
             &else &do
               &type    STREAM %creek%_f does not exist!
               &goto Fini
               &end
          CONTOUR %lake_ctr% Z_metric
          OUTPUTS %dem%_sink %dem%_drain %dem%_diag

          /* attempt to use local copy of fctr first
          &if [exists %cont_cov% -cover] &then
             CONTOUR %cont_cov% Z_metric
             &else &call read_paths
          /* see if this tile has Alaska or BC point data
          &do pnts &list ak_pnt bc_elv
              &if [exists %pnts% -point] &then
                  POINT %pnts% Z
/*&stop /* debug line
          &delvar Tol_*
       END /* exit topogrid config and make dem

         /* trap any errors
         &set check = %aml$sev%
         &if %check% ne 0 &then
            /* report errors
            &type ......Trapped error message => [value aml$message]
            &sys echo [value aml$message] > "[value aml$message].err"

         &severity &error &routine bail

         &format %save_format%   /* restore saved &format settings

         &type ...                    [date -vfull] * Minutes since last: [calc [extract 2 [show &pt all]] / 60]

         /* restore default cellsize, see Tolerances routine for what's up.
         &if [variable cellsave] &then &do
            &set cellsize = %cellsave%
            &delvar cellsave
            &end

      /* clip dem to 1km border
      &if [exists %dem%] &then &do
         latticeclip %dem% %boundary% %dem%_clip
         kill %dem% all
         rename %dem%_clip %dem%; &ty ...Renamed %dem%_clip to %dem%
         &end

    &label Fini

    &if [locase[show program]] = topogrid &then QUIT

    &if [exists %dem% -grid] &then &call float2int /* convert to integer grid

    &workspace ..
    /*--------------------------------
    &if [close %lockfile%] = 0 &then
        &type ...workspace %tile% unlocked
        &else &return Error closing lockfile
    &sys del %tile%\lock
    /*--------------------------------
/*&stop /*debug break point
&RETURN
/* ===========================================================================
/* --------------------------------------------------------------------------
&routine read_paths
   /* read in list of overlapping contour coverages from text file,
   /* generate CONTOUR <coverage> Z line for each
   &set pathfile = overlap.path.bare
   &s fileunit = [open %pathfile% openstat -read]
      &if %openstat% <> 0 &then
          &return &warning Error opening %tile%\%pathfile% (%openstat%)
   &s src =
   /* Read from file
   &setvar line := [read %fileunit% readstat]
      &if %readstat% <> 0 &then
        &return &warning Could not read %tile%\%pathfile% (%readstat%)
   &do &while %readstat% = 0
      /* -----------------------------
      /* these lines get passed up to Topogrid
       CONTOUR [unquote %line%]\%cont_cov% Z_metric
      /*------------------------------
      /* Read next line.
      &setvar line := [read %fileunit% readstat]
   &end
   &s closestat = [close %fileunit%]
      &if %closestat% <> 0 &then
          &return &warning Error closing %tile%\%pathfile% (%closestat%)
&return
/* --------------------------------------------------------------------------
&routine tolerances  /* get list unique elevation values for center tile,
/* identify interval distance, and total elevation span
/* Tolerance 1 is half the contour interval
/* Tolerance 2 is half the total relief (min-max elevation)

   /* in order to ignore "Result too long" errors
   &severity &error &ignore
   &delvar unique
   /* list unique elevation values for center tile
   /*&set unique = [listunique %.library%\%quad%\%tile%\%cont_cov%.aat -info z_metric]
   &set unique = [listunique %cont_cov%.aat -info z_metric]
   /* if var 'unique' does not exist, it's because listunique result was too long, therefore we assume the interval is 20m and the span is 2000m
   &if not [variable unique] &then &set unique = 600 620 2600

   /* get the first two values (which are the lowest)
   &set val_1 = [extract 1 %unique%]
   &set val_2 = [extract 2 %unique%]
   /* and the last (also the maximum)
   &set count = [token %unique% -count]
   &set last = [extract %count% %unique%]

   /* if 'count' is too low, it's because token-count result was too long
   &if not %count% > 2 &then &do
      &set val_1 = 600 ; &set val_2 = 620 ; &set last = 2600
      &end

   /* subtract from each other to get the contour interval, divide by 2
   &set half = ( %val_2% - %val_1% ) / 2
   /* strip everything after the decimal
   &set Tol_1 = [before [quote %half%] .]

   /* find half total elevation span
   &set half = ( %last% - %val_1% ) / 2
   /* strip everything after the decimal
   &set Tol_2 = [before [quote %half%] .]

   &type     half contour interval is %Tol_1% meters. Half relief is %Tol_2%.

   /* If the number of datapoints relative to cellsize is too large Topogrid will crash with a segment violation, therefor make the cellsize smaller.
   /* Garumph! this workaround doesn't work. :((
   /* &if %tol_1% < 20 &then &do
   /*    &set cellsave = %cellsize%
   /*    &set cellsize = %tol_1%
   /*    &end

   /* clean out temporary variables
   &delvar val_* count last half unique
/* Special Note: Tol_2 is not used yet, it is specific to ANUDEM (skip sink clearing for greater heights greater than this value; it's for dealing with saddles). TOPOGRID's Tol_2 is a measure of Horizontal standard error and deals with surface generalizing.
   &Set Tol_2 = 1.0 /* for Topogrid
&return
/* --------------------------------------------------------------------------
/* --------------------------------------------------------------------------
&routine float2int /* convert floating point to integer in order to conserve disk space
   &describe %dem%          /* skip if already integer
      &if %grd$type% = 1 &then &return
   GRID ; &type ...converting %dem% from floating point to integer
      &s scratch = [scratchname] /* generate temp grid name
      %scratch% = INT(%dem%)   /* convert to integer
   QUIT
   kill %dem% all           /* kill original grid
   rename %scratch% %dem%   /* rename temp to original
      &type    renamed %scratch% to %dem%
&return
/* --------------------------------------------------------------------------
/* --------------------------------------------------------------------------
&routine kill_prev
    &type ...killing off Round I mistakes
    &if [exist flip_grd -grid] &then kill flip_grd all
    &if [exist flip_sink -cover] &then kill flip_sink all
    &if [exist flip_drain -cover] &then kill flip_drain all
    &sys if exist flip_diag del flip_diag
&return
/* --------------------------------------------------------------------------
&routine kill_diags

   &do fer_cover &list %dem%_sink %dem%_drain
      &if [exists %fer_cover% -cover] &then kill %fer_cover% all
   &end

   &do fer_grid &list %dem%_flak %dem%_hs
      &if [exists %fer_grid% -grid] &then kill %fer_grid% all
   &end

   &do fer_file &list %dem%_is_100m %dem%_hs_is_100m flake.done %dem%_diag
      &if [exists %fer_file% -file] &then &sys del %fer_file%
   &end

&return
/* ===========================================================================
